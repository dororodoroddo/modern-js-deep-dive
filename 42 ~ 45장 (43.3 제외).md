# 42장 비동기 프로그래밍
## 42.1 동기 처리와 비동기 처리
- 코드가 실행되기 위해서는 코드 평가 과정을 거치게 되고 생성된 실행 컨텍스트가 실행 컨텍스트 스택에 푸시가 되는데, 자바스크립트 엔진은 단 하나의 실행 컨텍스트 스택을 갖는다.
- 자바스크립트는 싱글 스레드로 동작하여 한 번에 하나의 태스크만 수행할 수 있기 때문에 오래 걸리는 작업을 수행하는 경우에는 블로킹이 발생하고 이렇게 대기하는 방식을 동기 처리라고 한다.
- 타이머 함수와 HTTP 요청, 이벤트 핸들러는 이후 함수의 태스크를 블로킹하지 않고 곧바로 실행하고 이를 비동기 처리라고 한다.
## 42.2 이벤트 루프와 태스크 큐
- 싱글 스레드로 동작하는 자바스크립트에서 동시성을 지원하기 위한 것이 이벤트 루프다. 이벤트 루프는 브라우저에 내장된 기능으로 브라우저 환경은 크게 자바스크립트 엔진, 태스크 큐로 구분된다.
- 자바스크립트 엔진
	- 자바스크립트 엔진은 크게 콜 스택과 힙으로 구분할 수 있다.
	- 콜 스택
		- 실행 컨텍스트가 추가되고 실행이 완료되어 제거되는 실행 컨텍스트 스택
		- 콜 스택이 비워지기 전까지 다른 태스크를 실행하지 않음
	- 힙
		- 객체가 저장되는 메모리 공간
		- 객체의 크기는 런타임에 동적으로 결정되기 때문에 힙은 구조화되어 있지 않은 메모리 공간이다.
	- 자바스크립트 엔진은 태스크가 요청되면 콜 스택을 통해 실행할 뿐, 소스코드의 평가와 실행을 제외한 모든 처리는 브라우저가 담당한다
- 태스크 큐
	- 타이머 함수나 이벤트 핸들러가 일시적으로 보관되는 영역이다.
	- 프로미스의 후속 처리 콜백이 일시적으로 보관되는 마이크로태스크 큐도 존재한다
- 이벤트 루프
	- 콜 스택에 현재 실행 중인 실행 컨텍스트가 있는지, 그리고 태스크 큐에 대기 중인 함수가 있는지 반복해서 확인한다. 만약 콜 스택이 비어있고 태스크 큐에 대기 중인 함수가 있다면 순차적으로 콜 스택으로 이동시킨다.

- 싱글 스레드 방식으로 동작하는 것은 브라우저가 아닌 자바스크립트 엔진 뿐이라는 것을 유의하자

___
# 43장 Ajax
## 43.1 Ajax란?
- 자바스크립트를 사용하여 브라우저가 서버에게 비동기 방식으로 데이터를 요청하고 서버가 응답한 데이터를 수신하여 웹페이지를 동적으로 갱신하는 프로그래밍 방식을 말한다.
- 장점
	- 변경할 부분을 갱신하는 데 필요한 데이터만 서버로부터 전송받기 때문에 불필요한 데이터 통신이 발생하지 않는다.
	- 변경할 필요가 없는 부분은 다시 렌더링하지 않는다. 따라서 화면이 순간적으로 깜빡이는 현상이 발생하지 않는다.
	- 클라이언트와 서버와의 통신이 비동기 방식으로 동작하기 때문에 서버에게 요청을 보낸 이후 블로킹이 발생하지 않는다.
## 43.2 JSON (자바스크립트 오브젝트 노테이션)
- 클라이언트와 서버 간의 HTTP 통신을 위한 텍스트 데이터 포맷이다. 자바스크립트에 종속되지 않는 언어 독립형 데이터 포맷으로, 대부분의 프로그래밍 언어에서 사용이 가능하다.
- 표기 방식
	- 객체 리터럴과 유사하게 키와 값으로 구성한다
	- 키(와 문자열)는 반드시 큰따옴표로 묶어야 한다.
	- 값은 다른 리터럴 표기법을 그대로 사용할 수 있다.
- JSON.stringify : 객체를 JSON 포맷의 문자열로 변환하는 메서드
- JSON.parse : JSON 포맷의 문자열을 객체로 변환하는 메서드

___
# 44장 REST API
## 44.1 REST API의 구성
| 구성 요소 | 내용                | 표현 방법       |
| ----- | ----------------- | ----------- |
| 자원    | 자원                | URI(엔드포인트)  |
| 행위    | 자원에 대한 행위         | HTTP 요청 메서드 |
| 표현    | 자원에 대한 행위의 구체적 내용 | 페이로드        |
## 44.2 REST API 설계 원칙
1. URI는 리소스를 표현해야 한다.
	- 리소스를 표현하는 데에만 집중하여 동사보다는 명사를 사용한다.
2. 리소스에 대한 행위는 HTTP 요청 메서드로 표현한다
	- GET : 모든/특정 리소스 취득 (페이로드는 원칙적으로는 X)
	- POST : 리소스 생성 (멱등성 X)
	- PUT : 리소스의 전체 교체
	- PATCH : 리소스의 일부 수정 (멱등성 애매)
	- DELETE : 모든/특정 리소스 삭제 (페이로드는 원칙적으로는 X)
## 44.3 JSON Server를 이용한 REST API 실습
- JSON 서버를 설치해서 db.json 생성 후 활용해보기
___
# 45장 프로미스
## 45.1 비동기 처리를 위한 콜백 패턴의 단점
- 콜백 지옥
	- 비동기 함수를 호출하면 함수 내부에 비동기로 동작하는 코드에서 처리 결과를 외부로 반환하거나 상위 스코프 변수에 할당해도 종료 이후 동작하여 의미가 없다
	- 비동기 처리 결과는 비동기 함수 내부에서 처리해야 하므로 결과의 후속 처리 수행을 위해서 콜백함수를 전달하여 실행시킬 수 있다.
	- 이러한 비동기 처리 이후 새로운 비동기 처리가 연결되게 된다면 콜백함수 내부에 콜백함수가 중첩되어 복잡도가 높아지게 되고 이를 콜백 지옥이라고 한다.
- 에러 처리의 한계
	- 비동기 함수는 호출이 되고 바로 종료되기 때문에 호출한 외부에서 catch로 에러를 잡아낼 수 없다
## 45.2 프로미스의 생성
- new Promise()로 호출하면 프로미스 객체를 생성한다. ES6에서 도입된 표준 빌트인 객체이다
- 생성자 함수는 비동기 처리를 수행할 콜백함수를 인수로 전달받는데 콜백 함수는 resolve 함수와 reject 함수를 인수로 전달받는다.
- 콜백함수에서는 비동기 처리가 성공하면 resolve 함수를, 실패하면 reject 함수를 호출한다.
- 프로미스의 상태는 세가지 상태를 갖는다.
	- pending : 비동기 처리가 아직 수행되지 않은 상태, 프로미스가 생성된 직후 기본 상태이다.
	- settled : 비동기 처리가 수행된 상태로 fulfilled와 rejected 상태를 묶어서 말한 것
		- fulfilled : resolve 함수가 호출되어 비동기 처리가 성공적으로 수행된 상태
		- rejected : reject 함수가 호출되어 비동기 처리가 실패로 수행된 상태
## 45.3 프로미스의 후속 처리 메서드
- 비동기 처리 상태가 변화하면 후속 처리 메서드에 인수로 전달한 콜백 함수가 선택적으로 호출된다.
- Promise.prototype.then 
	- 두 개의 콜백 함수를 인수로 전달 받는다.
	- 첫 번째는 fulfilled 상태가 되면 호출되며 프로미스의 비동기 처리 결과(resolve의 인수)를 인수로 받는다
	- 두 번째는 rejected 상태가 되면 호출되며 프로미스의 비동기 에러(reject의 인수)를 인수로 받는다
	- 항상 프로미스를 반환한다.
- Promise.prototype.catch
	- 프로미스가 rejected일 때 호출할 콜백 함수를 인수로 받는다.
- Promise.prototype.finally
	- 프로미스가 settled가 되면 호출할 콜백 함수를 인수로 받는다.
## 45.4 프로미스의 에러 처리
- then 함수의 두번쨰 인수와 catch의 인수에서 에러 처리를 할 수 있으나 then의 첫 번째 함수에서 발생하는 오류를 두 번째 함수의 에러 콜백으로 캐치할 수 없기 때문에 then의 첫 번째 함수에서 비동기 처리 이후 로직을 수행하고 다음 catch에서 에러를 잡는 것이 가독성이 좋고 명확하다.
## 45.5 프로미스 체이닝
- 프로미스의 후속 처리 메서드는 언제나 프로미스를 반환하므로 연속적으로 then, catch, finally 후속 처리 메서드를 연결하여 호출할 수 있다. 이를 프로미스 체이닝이라고 한다.
- 각 후속 처리 함수는 앞에서 콜백 함수가 반환한 값을 인수로 받아 함수를 처리한다.
- 프로미스 체이닝도 콜백 패턴을 사용하므로 ES8의 async/await을 사용하는 것이 가독성에 좋을 수 있다.
## 45.6 프로미스의 정적 메서드
- Promise.resolve / Promise.reject
	- 이미 존재하는 값을 래핑하여 프로미스를 생성하기 위해 사용한다.
- Promise.all
	- 여러 개의 비동기 처리를 병렬로 실행시키기 위해 사용한다.
	- 모든 프로미스가 모두 fulfilled가 될 때 종료하고 배열의 첫 번째 원소로 받은 프로미스부터 순서대로 결과를 배열에 반환한다.
	- 하나라도 rejected가 된다면 나머지 상태를 기다리지 않고 즉시 종료한다. 이때, 가장 먼저 reject한 에러가 catch로 전달된다.
	- 인수의 요소가 프로미스가 아닌 경우 Promise.resolve로 래핑한다.
- Promise.race
	- all과 유사하나, 첫 번째로 fulfilled가 된 요소의 프로미스를 즉시 반환하고 종료한다는 차이가 있다.
- Promise.allSettled
	- all / race와 다르게 모든 요소의 처리 결과를 기다리고 각 요소의 처리 상태를 배열에 담아 반환한다.
## 45.7 마이크로태스크 큐
- 프로미스의 후속 처리 메서드는 마이크로태스크 큐에 저장이된다.
- 마이크로태스크큐는 태스크큐보다 우선순위가 높기 때문에 setTimeout 이후 프로미스를 추가해도 프로미스의 콜백 처리가 우선된다.
## 45.8 fetch
- HTTP 요청 전송 기능을 제공하는 클라이언트 사이드 Web API다. 
- HTTP 응답을 나타내는 Response 객체를 래핑한 프로미스 객체를 반환한다.
- 요청이 성공적으로 전송되면 프로미스는 기본적으로 HTTP 에러가 발생해도 에러를 reject하지 않고 불리언 타입의 ok의 상태를 false로 설정해 resolve한다.
- 오프라인 등 네트워크 장애나 CORS 에러에 의해 요청이 완료되지 못할 때, reject가 된다.
