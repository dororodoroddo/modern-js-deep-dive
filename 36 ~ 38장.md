# 36장 디스트럭처링 할당
- 구조 분해 할당
## 36.1 배열 구조 분해 할당
- 배열 구조 분해 할당의 대상(할당문의 우변)은 이터러블이어야 하며, 할당 기준은 배열의 인덱스로 인덱스에 따라 좌변에 할당된다.
- 함수 매개변수에 할당하는 것과 유사하게 좌변에 Rest 파라미터를 사용하여 마지막 변수에 나머지를 모두 할당 가능하다.
## 36.2 객체 디스트럭처링 할당
- 객체 구조 분해 할당의 대상의 우변은 객체이며, 할당 기준은 객체의 키다.
- 키가 일치하는 밸류에 할당을 하는데, 키와 할당받을 변수의 이름이 같다면 축약 표현을 사용할 수 있다.
- 배열처럼 Rest 프로퍼티를 마지막에 사용하여 남은 키를 가진 객체를 할당 가능하다.

___
# 37장 Set과 Map
## 37.1 Set
- 중복되지 않는 유일한 값들의 집합이다.
- 집합이기 때문에 순서에 의미가 없어 인덱스로 접근이 불가하다.
- 생성자 함수는 이터러블을 인수로 전달받아 중복을 제거하고 Set 객체를 생성한다.
- Set.prototype.size : 요소의 개수
- Set.prototype.add() 요소 추가
- Set.prototype.has
- Set.prototype.delete
- Set.prototype.clear
- Set.prototype.forEach     : Set은 이터러블이기 때문
- 집합연산
	- Set.prototype.intersection : 교집합
	- Set.prototype.union : 합집합
	- Set.prototype.difference : 차집합
	- Set.prototype.isSuperset : 상위집합 여부 확인
## 37.2 Map
- 객체와 유사하지만 차이가 있다
	- 키로 객체를 포함한 모든 값을 사용 가능하다
	- 이터러블이다
	- 요소의 갯수는 map.size로 확인 가능하다
- Map 생성자 함수는 이터러블을 인수로 전달받아 Map 객체를 생성한다. 이때 인수로 전달되는 이터러블은 키와 값의 쌍으로 이루어진 요소로 구성되어야 한다.
- Map.prototype.size
- Map.prototype.set : 요소 추가
- Map.prototype.get
- Map.prototype.has
- Map.prototype.delete
- Map.prototype.clear
- Map.prototype.forEach
- Map.prototype.keys
- Map.prototype.values
- Map.prototype.entries

___
#  38장 브라우저의 렌더링 과정
- 브라우저가 HTML, CSS, JS로 작성된 텍스트 문서를 파싱(구문 분석)하여 렌더링(시각적으로 출력)하는 과정
- ![[Pasted image 20240421113408.png]]
## 38.1 요청과 응답
- 브라우저의 핵심 기능은 필요한 리소스를 서버에 요청하고 응답받아 브라우저에 시각적으로 렌더링하는 것
- 특정 URI에 데이터를 요청하게 되면 서버는 정해진 리소스, 특히 웹 사이트라면 HTML 파일을 응답하게 된다.
- html을 응답을 받아 html을 파싱하는 도중 외부 리소스를 로드하는 태그 link, script, img 등을 만나게 되면 파싱을 일시 중단하고 해당 리소스 파일을 서버로 요청한다.
## 38.2 HTTP 1.1과 HTTP 2.0
- 웹에서 브라우저와 서버가 통신하기 위한 프로토콜
- HTTP 1.1
	- 하나의 커넥션 당  하나의 요청과 응답을 처리한다.
	- 각각의 리소스 요청이 개별적으로 전송되고 개별적으로 응답하여 리소스의 수가 늘어나면 응답시간이 느려진다.
- HTTP 2.0
	- 하나의 커넥션에 여러 요청과 응답이 처리된다.
## 38.3 HTML 파싱과 DOM 생성
- 순수한 텍스트인 html을 바이트 형태로 응답받아 meta태그의 charset 어트리뷰트에 의해 지정된 인코딩 방식을 기준으로 문자열로 변환한다. (메타태그의 charset 어트리뷰트는 응답 헤더 담긴다.)
- 문자열로 변환된 HTML문서를 읽어 문법적 의미를 갖는 최소 단위(토큰)으로 분해한다.
- 각 토큰들을 객체로 변환하여 노드 들을 생성한다. 토큰의 내용에 따라 문서 노드, 요소 노드, 어트리뷰트 노드, 텍스트 노드가 생성된다. 노드는 이후 DOM을 구성하는 기본 요소가 된다.
- HTML 문서는 HTML 요소들의 집합으로 이루어지며 HTML 요소는 중첩 관계를 갖는다. 이러한 중첩 관계에 의해 부자 관계가 형성되고 트리 자료구조가 되어 이를 DOM이라고 부른다.
## 38.4 CSS 파싱과 CSSOM 생성
- HTML을 파싱하는 도중 link나 style 태그를 만나면 DOM 생성을 일시 중단하고 css를 요청/해석한다.
- css는 HTML과 동일하게 바이트 -> 문자 -> 토큰 -> 노드 -> CSSOM의 단계로 해석해여 CSSOM을 생성한다.
- css는 상속을 반영하여 상속이 가능한 프로퍼티는 아래로 상속 된다.
## 38.5 렌더 트리 생성
- DOM과 CSSOM을 결합해 렌더 트리를 만든다.
- 렌더 트리는 브라우저 화면에 표시되는 노드들만 이루어 진다.
- 렌더 트리는  각 HTML 요소의 레이아웃(위치와 크기)을 계산하는 데 사용되며 픽셀을 렌더링하는 페인팅 처리에 입력된다.
- 위의 과정은 특정 상황에서 반복하여 재실행 될 수 있다.
	- 자바스크립트에 의한 노드의 추가/삭제
	- 브라우저 창의 리사이징에 의한 뷰포트 크기 변경
	- 레이아웃에 변경을 발생시키는 스타일의 변경
## 38.6 자바스크립트 파싱과 실행
- 자바스크립트의 파싱과 실행은 브라우저의 자바스크립트 엔진에 의해 DOM API를 제공받아 처리된다.
- 자바스크립트의 코드를 파싱하여 CPU가 이해할 수 있는 저수준 언어로 변환하고 실행한다.
- DOM과 CSSOM처럼 AST(추상적 구문 트리)를 생성하여 AST 기반으로 인터프리터가 실행할 수 있는 바이트코드를 생성하여 실행한다.
- 용어
	- 토크나이징 : 단순한 문자열인 소스코드를 어휘 분석하여 문법적 의미를 갖는 최소 단위로 분해
	- 파싱 : 구문 분석하여 AST를 생성. AST는 토큰에 문법적 의미와 구조를 반영한 트리 구조
	- 바이트코드 생성과 실행 : 인터프리터가 실행할 수 있는 중간 코드로 변환하여 실행
## 38.7 리플로우와 리페인트
- 자바스크립트 코드에 의해 DOM이나 CSSOM이 변경된 경우 렌더 트리에 변화를 일으키게 되고 이 렌더 트리를 기반으로 레이아웃과 페인트 과정을 거쳐 브라우저에 다시 렌더링이 되는 것
- 리플로우 - 레이아웃 계산을 다시하는 것으로 노드의 추가/삭제, 크기, 위치 변경, 윈도우 리사이징 등 전체적인 위치 관계 계산이 불가피한 경우 발생한다.
- 리페인트 - 렌더 트리를 기반으로 다시 페인트하는 것
## 38.8 자바스크립트 파싱에 의한 HTML 파싱 중단
- 자바스크립트 엔진은 병렬적으로 파싱을 실행하지 않고 직렬적으로 수행한다.
- 자바스크립트를 body 최하단에 두면 좋은 점
	- DOM이 완성되지 않은 상태에서 자바스크립트가 DOM을 조작하면 에러가 발생할 수 있다.
	- 로딩/파싱/실행으로 인해 html 렌더링이 지장받는 일이 생기지 않아 FP가 빨라진다.
## 38.9 script 태그의 async/defer 어트리뷰트
- DOM 파싱중단 문제 해결을 위해 async와 defer 어트리뷰트가 추가되었다.
- async
	- html 파싱과 자바스크립트의 로드가 비동기적으로 동시에 진행된다. 자바스크립트의 파싱과 실행은 로드 직후 발생하며 이때 html 파싱이 중단된다.
	- 순서의 보장 없이 로드가 완료되는 순서대로 진행된다.
- defer
	- 로드는 비동기적으로 동시에 진행되면서 자바스크립트의 파싱과 실행은 html 파싱이 완료된 직후 호출을 한 순서가 보장되어 실행된다.

