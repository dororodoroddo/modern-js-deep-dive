# 9장 타입 변환과 단축 평가
## 9.1 타입 변환이란?
개발자가 의도적으로 타입을 변환하는 것이 명시적 타입 변환/타입 캐스팅이라 하고 의도와 상관없이 표현식을 평가하는 도중 자동으로 변환되는것을 암묵적 타입 변환/타입 강제 변환이라고 한다.
## 9.2 암묵적 타입 변환
- 문자열
	- \+ 연산자는 양쪽의 피연산자 중 하나 이상이 문자열이면 암묵적 변환을 한다. (한 줄에 한 개 이상 아님)
	- 탬플릿 리터럴의 \$\{\}는 항상 문자열로 변환한다.
- number: 변환 불가 시에는 NaN이 된다.
	- +를 제외한 산술 연산자는 숫자로 변환된다
	> 비교연산자는 양쪽이 모두 문자열이면 사전순, 하나 이상이 숫자면 숫자로 변환되어 계산된다.
	
	- 비트 연산자는 숫자로 변환 후 32비트 정수로 변환된다. 큰 수 입력시 me+n 꼴로 변환돼서 계산이 안된다.
	- \[\]는 0이지만 \{\}는 NaN인 이유?
	![[Pasted image 20240128160021.png]] ![[Pasted image 20240128160453.png]]
- boolean
	- 제어문의 조건식은 불린이 된다
	- undefiend, null, 0, -0, NaN, ''은 모두 falsy하며 빈 배열은 객체이므로 truthy.

## 9.3 명시적 타입 변환
빌트인 매서드를 활용하자

## 9.4 단축 평가
표현식의 전체를 확인하지 않아도 결과를 예측할 수 있을 때 단축 평가가 이뤄진다.
- 논리연산자 \(\&&, ||\)
	- 좌항의 값에 따라 전체의 값을 예측할 수 있어 &&의 경우 좌항이 truthy면, ||의 경우 좌항이 falsy면 우항의 값을 평가하지 않고 우항을 그대로 반환한다.
- 옵셔널 체이닝 연산자 \(\?\.\)
	- 좌항의 피 연산자가 null 또는 undefined인 경우 undefined를 반환하고 그렇지 않으면 우항의 프로퍼티 참조를 이어간다.
- null 병합 연산자 \(??\)
	- 좌항이 falsy한지를 보는 ||와 다르게 ??는 좌항의 값이 null 또는 undefined일 경우 우항을 반환한다.
 
___
# 10장 객체 리터럴
## 10.1 객체란?
- 원시 타입은 하나의 값만 나타내지만 객체타입은 원시 값 또는 다른 객체를 하나의 단위로 구성한 복합적인 자료구조다. 원시 타입의 값, 즉 원시 값은 변경 불가능한 값이지만 객체 타입의 값, 즉 객체는 변경 가능한 값이다. 
- 객체는 0개 이상의 프로퍼티로 구성된 집합이며, 프로퍼티는 키와 값으로 구성된다.
- 함수는 일급 객체이므로 프로퍼티 값이 될 수 있으며, 값이 함수일 경우 메서드라고 부른다.
## 10.2 객체 리터럴에 의한 객체 생성
- 객체는 다양한 방법으로 생성할 수 있다
	- 객체 리터럴
		- \{\} 안에 0개 이상의 프로퍼티를 정의한다.
	- Object 생성자 함수
	- 생성자 함수
	- Object.create 메서드
	- class
## 10.3 프로퍼티
- 객체는 프로퍼티의 집합이며, 키와 값으로 구성된다. 키값은 빈 문자열을 포함하는 모든 문자열 또는 심벌 값으로 설정할 수 있다. 식별자 네이밍 규칙을 준수하는 이름이 아닌 경우 따옴표로 묶어야 설정이 가능하다. 프로퍼티 키를 표현식을 통해 동적으로 접근하려면 대괄호 표기법으로 접근할 수 있다.
- 프로퍼티의 값은 모든 타입을 사용할 수 있다.
- 문자열이나 심벌 이외의 값을 사용해 키를 생성하려고 하면, 이는 암묵적 변환을 통해 문자열이 된다.
- 중복 선언시 뒤에 선언한 프로퍼티가 앞 프로퍼티를 뒤집어 씌운다.
## 10.4 메서드
프로퍼티의 값으로 함수를 사용할 때, 프로퍼티를 매서드로 부르며 객체에 묶여있는 함수를 의미한다.

## 10.5 프로퍼티 접근
닷 노테이션과 브라킷 노테이션이 있다. 접근 시 존재하지 않은 프로퍼티면 오류 대신 undefined를 반환한다.
> 브라우저에서 코드 실행 시 전역객체 window에서 참조를 하기 때문에 name을 참조하면 window.name을 참조하여 기본값인 ''을 반환한다.
## 10.6 프로퍼티 값 갱신
이미 존재하는 프로퍼티에 재할당을 하면 값이 갱신된다.

## 10.7 프로퍼티 동적 생성
존재하지 않는 프로퍼티에 할당 시 키가 동적으로 생성되어 추가된다.

## 10.8 프로퍼티 삭제
delete 연산자는 피연산자의 프로퍼티를 제거한다. delete 연산자의 피연산자는 프로퍼티 값에 접근할 수 
있는 표현식이어야 한다.

> 책 문구 태클?
> a = { a: {} }
> b = a.a
> 이렇게 할당 시 b에는 a.a 의 주소값이 할당되어 b를 수정하면 a.a를 접근하기 때문에 프로퍼티 값에 접근 가능한 표현식이 라고 할 수 있지 않을까?
> 그래서 피연산자는 프로퍼티에 접근하는 점표기법 혹은 대괄호 표기법을 사용한다라고 쓰는게 맞을것 같습니다.
>  \(delete b를 하면 브라우저에서는 window 객체에서 b를 제거하고 노드 환경에서는 Delete of an unqualified identifier in strict mode. 에러가 발생한다.\)

## 10.9 ES6에서 추가된 객체 리터럴의 확장 기능
- 객체 리터럴로 객체 생성 시에 프로퍼티의 값을 변수에서 참조하여 할당할 때, 프로퍼티 키와 변수 이름이 같다면 a = { x: x }를 a = { x }로 축약할 수 있다.
- 대괄호 표기법에서 계산된 프로퍼티 이름을 동적 생성할 수 있다.
- 메서드 생성시 function을 쓰지 않고 { a() { ... } }의 형태로 생성 가능하다.

___
# 11장 원시 값과 객체의 비교
- 원시 값은 변경 불가능한 값이다. 객체는 참조타입의 값으로 변경 가능한 값이다.
- 원시 값을 변수에 할당하면 변수에는 실제 값이 저장된다. 이에 비해 객체를 변수에 할당하면 변수에는 참조 값이 저장된다.
- 원시값을 다른 변수에 할당하면 원본의 값이 복사되어 저장된다. => 값에 의한 전달
- 객체를 다른 변수에 할당하면 원본의 참조값이 복사되어 전달된다. => 참조에 의한 전달

## 11.1 원시 값
- 변경 불가능 하다는 것은 변수가 아니라 값에 대한 진술로, 변수에 재할당시 새로운 값을 생성하여 새로운 메모리 공간에 저장 후 할당한다.
- 문자열도 불변이므로 str\[n\] = \'s\'와 같이 일부를 변경시키려 해도 변하지 않는다. 대신 오류도 발생하지 않는다.
> += 과 join의 차이
- 값에 의한 전달 - 값이 복사되어 새로운 메모리 공간에 할당되므로 다른 변수를 수정해도 원본 값은 변하지 않는다.
	> (UB)메모리 관리 방식에 따라 같은 공간을 참조하고 있다가 재할당이 발생하는 시점에 새 공간을 참조하기도 한다.
- 그런데 사실 값에 의한 전달은 JS의 공식적인 용어가 아니다. 엄격하게 표현하자면 변수에는 값이 아니라 주소가 전달된다. 하지만 새로운 변수와 기존 변수 간의 값의 간섭이 없기 때문에 구분하기 위한 용어이다.

## 11.2 객체
- 객체는 프로퍼티의 수가 정해져 있지 않으며, 동적으로 추가 삭제가 가능하여 메모리 공간의 크기도 동적이다.
- 객체는 변경 가능한 값이므로 재할당 없이 프로퍼티의 키나 값을 객체를 재할당 하지 않고 갱신이 가능하다.
- 여러 개의 식별자가 하나의 객체를 공유할 수 있다는 부작용이 있다.
	- 얕은 복사: 객체를 복사할 때 객체의 참조 주소만 복사한다
	- 깊은 복사: 객체를 복사할 때 모든 내부 프로퍼티들을 새로운 메모리 공간에 복사하여 참조를 차단한다.
- 참조에 의한 전달
	- 원본의 참조 값이 복사되어 전달된다. 그리하여 두 개의 식별자가 하나의 객체를 공유하게 된다.
	- 사실 값에의한 전달과 참조에 의한 전달 모두 식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사하는데, 저장되어 있는 값이 원시 값이냐 참조 값이냐에따라 동작이 달라진 것이다.
	- 객체간의 비교(\=\=, \=\=\=)시에는 참조 주소를 비교한다.