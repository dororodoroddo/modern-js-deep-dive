# 23장 실행 컨택스트
## 23.1 소스코드의 타입
- 소스코드의 종류
	- 전역 코드 
		- 전역에 존재하는 소스코드. 함수, 클래스 등의 내부는 미포함
		- var 전역 변수와 함수 선언문으로 정의된 전역 함수를 전역 객체의 프로퍼티와 메서드로 바이닝하고 참조하기 위해 전역 실행 컨텍스트가 생성된다
	- 함수 코드 
		- 함수 내부에 존재하는 소스코드. 내부에 중첩된 함수 제외
		- 지역 스코프를 생성하고 지역 변수, 매개변수, arguments 객체를 관리하며 지역 스코프를 전역 스코프에 연결하기 위해 함수 실행 컨텍스트가 생성된다.
	- eval 코드 
		- eval 함수에 인수로 전달되어 실행되는 소스코드
		- strict mode에서 독자적인 스코프를 생성하기 때문에 
	- 모듈코드 
		- 모듈 내부에 존재하는 소스코드. 중첩 제외.
		- 모듈별로 독립적인 모듈 스코프를 생성
## 23.2 소스코드의 평가와 실행
- 소스코드의 평가
	- 실행 컨텍스트를 생성하고 변수, 함수 등의 선언문만 먼저 실행하여 변수나 함수 식별자를 키로 스코프에 등록한다.
- 소스코드의 실행
	- 선언문을 제외한 소스코드가 순차적으로 실행되기 시작한다. 즉 런타임이 실행된다.
	- 변수나 함수의 참조를 실행 컨택스트의 스코프에서 검색하고 실행 결과를 다시 스코프에등록한다.
## 23.3 실행 컨텍스트의 역할
- 전역 코드 평가
	- 선언문 실행 및 스코프에 등록
	- 전역 객체에 등록
- 전역 코드 실행
	- 런타임이 시작
	- 변수 할당 및 함수가 호출
	- 함수 호출 시 전역 코드의 실행을 일시 중단하고 코드 실행 순서를 변경하여 함수 내부로진입
- 함수 코드 평가
	- 매개변수와 지역 변수의 선언문 실행 및 스코프에 등록
	- arguments 객체가 생성되어 지역 스코프에 등록되며 this바인딩이 결정
- 함수 코드 실행
	- 런타임이 시작

- 이처럼 코드가 실행되기 위해 스코프를 관리하고 식별자를 검색하며 코드 실행 순서를 의도한 대로 동작하도록 하는 것이 실행 컨텍스트이다.

## 23.4 실행 컨텍스트 스택
- 소스코드가 실행될 때, 함수의 호출이 중첩될 수 있고 여러 개의 실행 컨텍스트가 생성될 수 있다.
- 실행 컨텍스트는 스택으로 쌓이게 되며 최상위 실행 컨택스트는 언제나 현재 실행 중인 실행 컨텍스트이다.

## 23.5 렉시컬 환경
- 렉시컬 환경의 식별자와 식별자에 바인딩된 값, 그리고 상위 스코프에 대한 참조를 기록하는 자료구조로 실행 컨텍스트를 구성하는 컴포넌트
- 렉시컬 환경은 다음과 같이 두 개의 컴포넌트로 구성된다.
	- 환경 레코드
		- 스코프에 포함된 식별자를 등록하고 등록된 식별자에 바인딩된 값을 관리하는 저장소
		- 소스코드의 타입에 따라 관리하는 내용에 차이 존재
	- 외부 렉시컬 환경에 대한 참조
		- 상위 스코프를 가리킴
		- 상위 스코프는 외부 렉시컬 환경, 즉 해당 실행 컨텍스트를 생성한 소스코드를 포함하는 상위 코드의 렉시컬 환경을 의미
## 23.6 실행 컨텍스트의 생성과 식별자 검색 과정
- 전역 객체 생성
	- 전역 코드가 평가되기 이전에 전역 객체 생성
	- 표준 빌트인 객체와 호스트 객체를 추가
	- 전역 객체도 Object.prototype을 상속 받음
- 전역 코드 평가
	- 1 전역 실행 컨텍스트 생성 
		- 빈 실행 컨텍스트를 생성하여 실행 컨텍스트 스택에 푸시 
		- 이때 실행중인 실행 컨텍스트가 됨
	- 2 전역 렉시컬 환경 생성
		- 전역 렉시컬 환경을 생성하고 전역 실행 컨텍스트에 바인딩
		- 2-1 전역 환경 레코드 생성
			- 2-1-1 객체 환경 레코드 생성
			- 2-1-2 선언적 환경 레코드 생성
		- 2-2 this 바인딩
		- 2-3 외부 렉시컬 환경에 대한 참조 결정
- 전역 코드 실행
- foo 함수 코드 평가
- foo 함수 코드 실행
- bar 함수 코드 평가
- bar 함수 코드 실행
- bar 함수 코드 실행 종료
- foo 함수 코드 실행 종료
- 전역 코드 실행 종료
## 23.7 실행 컨텍스트와 블록 레벨 스코프
- if 문의 코드 블록이 실행되면 if문의 코드 블록을 위한 블록 레벨 스코프를 생성해야 한다.
- 이를 위한 선언적 환경 레코드를 갖는 렉시컬 환경을 새롭게 생성하여 기존의 렉시컬 환경을 교체한다.
- 이처럼 새로운 블록 문이 생성될 때마다 렉시컬 환경이 생성 된다.

___
# 24장 클로저
## 24.1 렉시컬 스코프
- 자바스크립트 엔진은 함수를 호출한 위치가 아닌 어디에 정의했는지에 따라 상위 스크포를 결정한다. (렉시컬 스코프 / 정적 스코프)
- 렉시컬 환경의 \"외부 렉시컬 환경에 대한 참조\"에 저장할 참조값, 즉 상위 스코프에 대한 참조는 함수 정의가 평가되는 시첨에 정의된 환경(위치)에 의해 결정된다. => 렉시컬 스코프
## 24.2 함수 객체의 내부 슬록 \[\[Environment\]\]
- 함수는 자신의 내부 슬롯 \[\[Environment\]\]에 자신이 정의된 환경, 즉 상위 스코프의 참조를 저장한다.
- 이때 그 참조는 현재 실행 중인 실행 컨텍스트의 렉시컬 환경을 가리킨다. (함수 객체를 생성하는 시점 === 상위 함수의 실행 컨텍스트가 실행중인 시점)

## 24.3 클로저와 렉시컬 환경
- 외부 함수보다 중첩 함수가 더 오래 유지되는 경우 중첩함수는 이미 생명 주기가 종료한 외부 함수의 변수를 참조할 수 있다. 이러한 중첩 함수를 클로저라고 부른다.
- outer 함수의 실행 컨텍스트가 종료되어도 outer 함수의 렉시컬 환경은 inner함수의 \[\[Environment\]\]에 의해 참조되고 있어 소멸되지 않는다.
- 일반적으로 이렇게 소멸되지 않는 상위 스코프를 중첩함수가 이용하여 외부 함수보다 더 오래 유지되는 경우만 클로저라고 부른다.

## 24.4 클로저의 활용
- 상태가 의도치 않게 변경되지 않도록 은닉하고 특정 함수에게만 상태 변경을 허용하기 위해 사용한다.

## 24.5 캡술화와 정보 은닉
- 캡슐화는 객체의 상태를 나타내는 프로퍼티와 프로퍼티를 참조하고 조장할 수 있는 동작인 메서드를 하나로 묶는 것을 말한다.
- 정보 은닉은 외부에 공개되지 않도록 감추어 적절하지 못한 접근으로부터 상태 변경을 막아 정보를 보호하고, 객체 간의 상호 의존성, 결합도를 낮추는 효과가 있다.

## 24.6 자주 발생하는 실수

___
# 25장 클래스
## 25.1 클래스는 프로토타입의 문법적 설탕인가?
- 클래스는 함수이며 기존 프로토타입 패턴을 유지하지만 클래스 기반 패턴인 것처럼 사용할 수 있도록 하기 때문에 문법적 설탕으로 볼 수도 있다.
- 클래스와 생성자 함수의 차이
	- class는 new 연산자 없이 호출이 불가능하다
	- 클래스는 상속을 지원하는 extends와 super가 제공된다.
	- 호이스팅이 발생하지 않는 것처럼 존재한다.
	- 클래스 내 모든 코드에는 strict mode가 강제된다.
	- 클래스의 모든 메서드는 열거되지 않는다.
- 이러한 차이로 문법적 설탕이 아닌 새로운 객체 생성 메커니즘일 뿐이다.

## 25.2 클래스 정의 
- class 키워드를 사용해 정의하며, 파스칼 케이스로 식별자를 만드는 것이 일반적
- 함수와 같이 표현식으로 정의할 수 있어 일급 객체라는 것을 의미한다.

## 25.3 클래스 호이스팅
- 클래스는 let, const와 동일하게 TDZ에 들어가 호이스팅 되어도 사용할 수 없다.

## 25.4 인스턴스 생성
- new 연산자와 함께 사용해야한.
- 표현식으로 생성시 기명 방식을 써도 할당한 변수의 식별자만 인식된다.

## 25.5 메서드
- 0개 이상의 메서드만 선언할 수 있다.
- 종류
	- constructor
		- 인스턴스를 생성하고 초기화하기 위한 특수 메서드로 이름 변경이 불가하다.
		- 내부의 this는 생성한 인스턴스를 가리킨다.
		- 프로토타입의 constructor 객체와 별개의 개념이다.
		- 생성자 함수와 같이 return문 사용시 원시값은 무시되고 객체는 인스턴스로 반환된다.
	- 프로토타입 메서드
		- 클래스는 기본적으로 생성시 프로토타입 메서드가 된다.
	- 정적 메서드
		- 메서드 앞에 static키워드를 붙이면 정적 메서드가 되어 인스턴스가 아닌 클래스로 호출해야한다.
		- 프로토타입 메서드와 프로토타입 체인이 다르다.
		- 인스턴스 프로퍼티를 참조할 수 없다.
- 클래스에서 정의한 메서드의 특징
	- function 키워드를 생략한 메서드 축약 표현을 사용한다.
	- 객체 리터럴과는 다르게 클래스에서는 콤마로 메서드를 나누지 않는다.
	- 암묵적으로 strict mode로 실행된다.
	- for ... in 문 등으로 열거할 수 없다.
	- 내부 메서드 \[\[ Construct \]\]를 갖지 않는 non-constructor다.
## 25.6 클래스의 인스턴스 생성 과정
- 인스턴스 생성과 this 바인딩
	- 인스턴스를 만들기위해 암묵적으로 빈 객체가 먼저 생성된다.
	- 인스턴스의 프로토타입으로 클래스의 프로토타입 프로퍼티가 가리키는 객체가설정된다.
	- 인스턴스는 this에 바인딩 된다.
- 인스턴스 초기화
	- 내부 코드가 실행되어 this에 바인딩되어 있는 인스턴스를 초기화한다.
	- constructor가 생략되었다면 이 과정도 생략한다.
- 인스턴스 반환
## 25.7 프로퍼티
- 인스턴스 프로퍼티
	- 인스턴스 프로퍼티는 constructor 네부에서 정의해야 한다.
	- 인스턴스 프로퍼티는 언제나 public하다
- 접근자 프로퍼티
	- 객체의 접근자 프로퍼티와 같다.
- 클래스 필드 정의 제안
	- 클래스 몸체에는 원래 메서드만 선언할 수 있지만 최신 브라우저에서는 클래스 필드를 클래스몸체에 정의할 수 있다.
	- 몸체에는 this가 유효하지 않다.
- private 필드 정의 제안
	- 식별자 선두에 \#을 붙인다
- static 필드 정의 제안

## 25.8 상속에 의한 클래스 확장
- 상속에 의한 클래스 확장은 기존 클래스를 상속받아 새로운 클래스를 확장하여 정의하는것.
- extends 키워드 : 클래스 선언을 할 때 식별자 뒤에 extends와 상속받을 클래스를 정의한다.
	- 서브 클래스 : 상속을 통해 확장된 클래스
	- 수퍼 클래스 : 상속된 클래스
	- 푸퍼 클래스와 서브 클래스는 인스턴스의 프로토타입 체인 뿐 아니라 클래스 간에도 생성하여 프로토타입 메서드, 정적 메서드 모두 상속된다.
- 동적 상속
	- 생성자 함수 등 constructor를 상속받아 클래스를 확장할 수도 있다.
- 서브클래스의 constructor
	- 생략시 부모의 constructor를 그대로 실행하는 것이 암묵적으로 정의된다.
- super 키워드
	- 함수처럼 호출할 수도 있고 this와 같이 식별자처럼 참조할 수 있다.
	- 호출 시 수퍼클래스의 contructor를 호출한다
	- 참조시 수퍼클래스의 메서드를 호출할 수 있다.(상위 클래스를 참조하는 것처럼 동작)
- 상속 클래스의 인스턴스 생성 과정
	- 1 서브클래스의 super호출
		- 자신이 직접 인스턴스를 생성하지 않고 수퍼클래스에게 인스턴스 생성을 위임한다.
		- 그래서 서브클래스에서는 super 호출이 필수다
	- 2 수퍼클래스의 인스턴스 생성과 this 바인딩
	- 3 수퍼클래스의 인스턴스 초기화
	- 4 서브클래스 constructor로의 복귀와 this바인딩
		- 수퍼의 반환값을 그대로 사용해 this를 바인딩한다.
		- super를 사용하기 전에는 this를 참조할 수 없는 이유다.
	- 5 서브클래스의 인스턴스 초기화
	- 6 인스턴스 반환
- 표준 빌트인 생성자 함수 확장
	- 메서드 체인을 주의해야한다.

